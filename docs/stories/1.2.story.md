# Story 1.2: Video Loading and Playback

## Status
Draft

## Story
**As an** ML developer,
**I want** to load and playback multi-frame image sequences,
**so that** I can analyze model behavior over time.

## Acceptance Criteria
1. Load sequence of images from float binary files of known width/height (Nx128x128 or Nx224x224)
2. Support uint8 and float32 input formats
3. Support scale and bias choice for float32 input format *(Note: Applied via shaders during rendering, not during data loading)*
4. Display current frame as texture in main window
5. Support frame-by-frame navigation (next/previous)
6. Implement play/pause functionality with looping
7. Display current frame number and total frames

## Tasks / Subtasks
- [ ] Task 1: Implement ImageSequence data model (AC: 1, 2, 3)
  - [ ] Create include/thor/core/ImageSequence.hpp with ImageSequence class
  - [ ] Implement src/data/ImageSequence.cpp with frame data storage
  - [ ] Support both uint8 and float32 pixel types (raw data, no transformations)
  - [ ] Provide GetImageView(frameIndex) method for zero-copy frame access
  - [ ] Add metadata properties (frameCount, width, height, channels, fps)
- [ ] Task 2: Create ImageLoader for binary file loading (AC: 1, 2, 3)
  - [ ] Implement src/data/ImageLoader.cpp/.hpp
  - [ ] Add LoadImageSequence(path, width, height, pixelType) method
  - [ ] Support reading Nx128x128 and Nx224x224 binary files
  - [ ] Handle both uint8 and float32 formats with proper byte ordering
  - [ ] Store raw pixel data unchanged in memory (no scale/bias applied)
- [ ] Task 3: Implement PlaybackController (AC: 5, 6, 7)
  - [ ] Create src/playback/PlaybackController.cpp/.hpp
  - [ ] Add Play(), Pause(), SetFrame(index), GetCurrentFrame() methods
  - [ ] Implement timing system using std::chrono for FPS-based playback
  - [ ] Support looping functionality when reaching end of sequence
  - [ ] Provide frame navigation (next/previous) controls
- [ ] Task 4: Extend DataManager for sequence management (AC: 1, 7)
  - [ ] Update src/data/DataManager.cpp/.hpp
  - [ ] Add LoadImageSequence(path) method using ImageLoader
  - [ ] Integrate with PlaybackController for current frame tracking
  - [ ] Provide GetCurrentImageView() method for UI consumption
- [ ] Task 5: Add texture rendering support with shader-based processing (AC: 4)
  - [ ] Update src/rendering/GLRenderer.cpp/.hpp
  - [ ] Add CreateTexture(imageView) and UpdateTexture(id, imageView) methods
  - [ ] Support both uint8 and float32 pixel data in OpenGL textures
  - [ ] Implement RenderTexturedQuad(scale, bias) with shader uniforms
  - [ ] Create GLSL shaders for scale/bias transformations during rendering
  - [ ] Add SetRenderingParameters(scale, bias) for dynamic adjustment
  - [ ] Implement efficient texture updates for playback
- [ ] Task 6: Create playback UI controls (AC: 5, 6, 7)
  - [ ] Update src/ui/UIManager.cpp/.hpp
  - [ ] Add play/pause button controls
  - [ ] Implement frame navigation (next/previous) buttons
  - [ ] Display current frame number and total frames
  - [ ] Add frame rate control for playback speed
- [ ] Task 7: Integrate components in Application (AC: 4, 5, 6, 7)
  - [ ] Update src/app/Application.cpp/.hpp
  - [ ] Initialize DataManager, PlaybackController, and GLRenderer
  - [ ] Wire up UI controls to playback functionality
  - [ ] Implement main rendering loop with texture display
- [ ] Task 8: Add comprehensive unit tests (All ACs)
  - [ ] Create tests/data/test_image_sequence.cpp
  - [ ] Create tests/data/test_image_loader.cpp
  - [ ] Create tests/playback/test_playback_controller.cpp
  - [ ] Create tests/rendering/test_gl_renderer.cpp (texture operations)
  - [ ] Test edge cases: empty sequences, invalid formats, boundary frames

## Dev Notes

### Previous Story Insights
- Strong foundation established with Modern C++ practices and RAII patterns [Source: Story 1.1 QA Results]
- Custom exception hierarchy in place - use `thor::Error` types, not `std::runtime_error` [Source: Story 1.1 QA Results]
- OpenGL 3.3 Core context properly initialized and working [Source: Story 1.1 QA Results] 
- Include style: use `<thor/>` angle brackets (not relative paths) [Source: Story 1.1 QA Results]
- Pre-allocated unique_ptr resources for performance in hot paths [Source: Story 1.1 QA Results]
- V-sync enabled for consistent frame timing [Source: Story 1.1 QA Results]

### Data Models
**ImageView** - Non-owning view into image data for zero-copy operations [Source: architecture.md#data-models]
- data: `std::span<const uint8_t>` or `std::span<const float>` - Non-owning view of pixel data
- width: uint32_t - Image width in pixels  
- height: uint32_t - Image height in pixels
- channels: uint32_t - Number of channels (1, 3, or 4)
- stride: size_t - Bytes per row (for alignment)
- pixelType: enum { UINT8, FLOAT32 } - Pixel data type

**ImageSequence** - Owns multi-frame image data with metadata [Source: architecture.md#data-models]
- frameData: `std::vector<uint8_t>` or `std::vector<float>` - Contiguous frame storage (raw, unmodified pixel data)
- frameCount: `uint32_t` - Number of frames
- width: `uint32_t` - Frame width in pixels
- height: `uint32_t` - Frame height in pixels  
- channels: `uint32_t` - Number of channels per frame
- pixelType: `ImageDataType` - UINT8 or FLOAT32
- fps: `float` - Playback framerate
- **Note**: Scale and bias transformations are applied in shaders during rendering, not during data storage

### Component Specifications
**DataManager** - Coordinates data loading and export [Source: architecture.md#components]
- LoadImageSequence(path) - Load multi-frame data
- GetImageView(frameIndex) - Get view of specific frame
- Dependencies: ImageLoader, DataExporter

**PlaybackController** - Controls playback state and current frame selection [Source: architecture.md#components]
- Play() - Start playback
- Pause() - Stop playback  
- SetFrame(index) - Jump to specific frame
- GetCurrentFrame() - Get current frame index
- SetFPS(fps) - Set playback speed
- Technology Stack: C++20 std::chrono for timing

**GLRenderer** - Low-level OpenGL rendering operations and texture management with shader-based image processing [Source: architecture.md#components]
- CreateTexture(imageView) - Create OpenGL texture from image
- UpdateTexture(id, imageView) - Update existing texture
- RenderTexturedQuad(scale, bias) - Draw image to screen with shader-based scale/bias
- SetRenderingParameters(scale, bias) - Configure shader uniforms for image display
- Technology Stack: OpenGL 3.3, GLSL shaders with scale/bias uniforms

### File Locations
Based on project structure [Source: architecture/source-tree.md]:
- **Headers**: include/thor/core/ (ImageSequence.hpp, Types.hpp)
- **Data Components**: src/data/ (ImageLoader.cpp/.hpp, ImageSequence.cpp/.hpp, DataManager.cpp/.hpp)
- **Playback Components**: src/playback/ (PlaybackController.cpp/.hpp)
- **Rendering Components**: src/rendering/ (GLRenderer.cpp/.hpp, Texture.cpp/.hpp)
- **UI Components**: src/ui/ (UIManager.cpp/.hpp)
- **Application**: src/app/ (Application.cpp/.hpp)
- **Binary Data**: data/clips/ (image sequence .bin files), data/models/ (CoreML .mlpackage files)
- **Test Data**: data/samples/ (sample sequences for testing), data/exports/ (runtime-generated files)

### Technical Constraints
- **Language**: C++20 with Apple Clang 14.0+ [Source: architecture/tech-stack.md]
- **Memory Management**: RAII with smart pointers, pre-allocated buffers [Source: architecture/coding-standards.md]
- **OpenGL**: Version 3.3 Core Profile [Source: architecture/tech-stack.md]
- **OpenGL Headers**: Never include OpenGL headers directly, always use GLFW headers [Source: architecture/coding-standards.md]
- **Rendering Separation**: OpenGL calls must only occur in src/rendering/ files, never in Application [Source: architecture/coding-standards.md]
- **Scale/Bias Processing**: Apply scale and bias transformations in GLSL shaders during rendering, NOT during data loading - preserve raw pixel data in memory [Source: architecture.md#components]
- **UI Framework**: Dear ImGui 1.90+ [Source: architecture/tech-stack.md]
- **Performance**: Sub-16ms frame times for interactive debugging [Source: architecture.md#high-level-architecture]
- **Error Handling**: C++ exceptions for runtime errors, use custom exception hierarchy [Source: architecture/coding-standards.md]

## Testing

### Testing Requirements
- **Framework**: GoogleTest 1.14+ [Source: architecture/tech-stack.md]
- **File Convention**: test_<source_file>.cpp [Source: architecture.md#test-strategy-and-standards]  
- **Location**: tests/ mirroring source structure [Source: architecture/coding-standards.md]
- **Pattern**: AAA pattern (Arrange, Act, Assert) [Source: architecture.md#test-strategy-and-standards]
- **Mocking**: GoogleMock for interfaces [Source: architecture.md#test-strategy-and-standards]
- **Coverage**: Test all public methods, edge cases, and error conditions [Source: architecture.md#test-strategy-and-standards]

### Specific Testing Requirements for Story 1.2
- Test binary file loading with various sizes (128x128, 224x224)
- Test both uint8 and float32 pixel formats (raw data preservation)
- Test shader-based scale and bias transformations during rendering
- Test playback timing accuracy and frame transitions
- Test boundary conditions (first/last frame, empty sequences)
- Test texture creation and updates with different pixel formats
- Test shader uniform parameter setting for scale/bias
- Mock file system operations for ImageLoader tests
- Use sample data from `data/samples/` directory for integration tests
- Test with known binary sequences from `data/clips/` for validation

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| [Today's Date] | 1.0 | Initial story creation | Bob (Scrum Master) |
| [Today's Date] | 1.1 | Updated scale/bias to shader-based processing, preserving raw data in memory | Winston (Architect) | 